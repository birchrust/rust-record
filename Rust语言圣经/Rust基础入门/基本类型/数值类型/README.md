#### 整数类型

**整数**是没有小数部分的数字。之前使用过的 `i32` 类型，表示有符号的 32 位整数（ `i` 是英文单词 *integer* 的首字母，与之相反的是 `u`，代表无符号 `unsigned` 类型）。下表显示了 Rust 中的内置的整数类型：

|    长度    | 有符号类型 | 无符号类型 |
| :--------: | :--------: | :--------: |
|    8位     |     i8     |     u8     |
|    16位    |    i16     |    u16     |
|    32位    |    i32     |    u32     |
|    64位    |    i64     |    u64     |
|   128位    |    i128    |    u128    |
| 视架构而定 |   isize    |   usize    |

- **无符号数**表示数字只能取正数和0，而**有符号**则表示数字可以取正数、负数还有0。
- 每个有符号类型规定的数字范围是 -(2<sup>n - 1</sup>) ~ 2<sup>n - 1</sup> - 1，其中 `n` 是该定义形式的位长度。无符号类型可以存储的数字范围是 0 ~ 2<sup>n</sup> - 1
- `isize` 和 `usize` 类型取决于程序运行的计算机 CPU 类型： 若 CPU 是 32 位的，则这两个类型是 32 位的，同理，若 CPU 是 64 位，那么它们则是 64 位。

例：`i8` 可存储数字范围是 -(2<sup>7</sup>) ~ 2<sup>7</sup> - 1，即 -128 ~ 127。`u8` 能够存储的数字为 0 ~ 2<sup>8</sup> - 1，即 0 ~ 255。

整形字面量可以用下表的形式书写：

|   数字字面量   |    示例     |
| :------------: | :---------: |
|     十进制     |   98_222    |
|    十六进制    |    0xff     |
|     八进制     |    0o77     |
|     二进制     | 0b1111_0000 |
| 字节(仅限于u8) |    b'A'     |

**Rust 整型默认使用 `i32`，同时该类型也往往是性能最好的。`isize` 和 `usize` 的主要应用场景是用作集合的索引。**

------

#### 浮点类型

**浮点类型数字** 是带有小数点的数字，在 Rust 中浮点类型数字也有两种基本类型： `f32` 和 `f64`，分别为 32 位和 64 位大小。默认浮点类型是 `f64`，在现代的 CPU 中它的速度与 `f32` 几乎相同，但精度更高。

**浮点数陷阱**：

1. 浮点数往往是你想要数字的近似表达：浮点数类型是基于二进制实现的，但是我们想要计算的数字往往是基于十进制，例如 `0.1` 在二进制上并不存在精确的表达形式，但是在十进制上就存在。这种不匹配性导致一定的歧义性，更多的，虽然浮点数能代表真实的数值，但是由于底层格式问题，它往往受限于定长的浮点数精度，如果你想要表达完全精准的真实数字，只有使用无限精度的浮点数才行
2. 浮点数在某些特性上是反直觉的： 例如大家都会觉得浮点数可以进行比较，对吧？是的，它们确实可以使用 `>`，`>=` 等进行比较，但是在某些场景下，这种直觉上的比较特性反而会害了你。因为 `f32` ， `f64` 上的比较运算实现的是 `std::cmp::PartialEq` 特征(类似其他语言的接口)，但是并没有实现 `std::cmp::Eq` 特征，但是后者在其它数值类型上都有定义。

为了避免上面说的两个陷阱，你需要遵守以下准则：

- 避免在浮点数上测试相等性
- 当结果在数学上可能存在未定义时，需要格外的小心
